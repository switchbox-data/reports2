---
title: "Analyze Missing HP in NY for Upgrade 02"
format: html
---

This notebook analyzes the missing HP in NY for Upgrade 02. NREL's documentation for 2024 ResStock release states that the HP will not be assigned to high-rise dwelling units with shared HVAC. Additionally, ducted heat pump portions of measure package will not apply to any shared HVAC dwelling unit. Additionally, the HP will not be assigned to dwelling units with other heating fuels (e.g., wood) or no heating system in the baseline. This notebook will analyze the missing HP in NY for Upgrade 02 and determine if the missing HP is due to the above restrictions.

```{python}
import polars as pl
import numpy as np
import seaborn as sns
from cloudpathlib import S3Path

# Read the NY metadata for Upgrade 02 with postprocess_group.has_hp column
sb_path = "s3://data.sb"
release = "res_2024_amy2018_2"
upgrade_id = "02"
state = "NY"
STORAGE_OPTIONS = {"aws_region": "us-west-2"}
metadata_path = S3Path(f"{sb_path}/nrel/resstock/{release}/metadata/state={state}/upgrade={upgrade_id}/metadata-sb.parquet")

# Exclude the cases where the customers had other fuel type or no heating to begin with.
exclude_other_heating_fuel = False

metadata = pl.scan_parquet(str(metadata_path), storage_options=STORAGE_OPTIONS)
if exclude_other_heating_fuel:
    col_hvac = pl.col("in.hvac_heating_type_and_fuel")
    excluded_bldg_ids = (
        metadata.filter(
            col_hvac.is_null()
            | col_hvac.str.contains("Other fuel", literal=True)
            | (col_hvac == "None")
        )
        .select(pl.col("bldg_id"))
        .collect()
        .to_series()
        .to_list()
    )
    metadata = metadata.filter(
        col_hvac.is_not_null()
        & ~col_hvac.str.contains("Other fuel", literal=True)
        & (col_hvac != "None")
    )
else:
    excluded_bldg_ids = []

```

### Count total number of customers without HP state wide
```{python}
total_customers_count = metadata.select(pl.len()).collect().row(0)[0]
no_hp_customers_count = metadata.filter(pl.col("postprocess_group.has_hp") == False).select(pl.len()).collect().row(0)[0]
print(f"Total customers: {total_customers_count}")
print(f"No HP customers: {no_hp_customers_count}")
print(f"Percentage of customers with no HP: {no_hp_customers_count / total_customers_count * 100:.2f}%")
```



### Count total number of customers without HP by utility
```{python}
utility_assignment_path = S3Path(f"{sb_path}/nrel/resstock/{release}/metadata_utility/state={state}/utility_assignment.parquet")
utility_assignment = pl.scan_parquet(
    str(utility_assignment_path), storage_options=STORAGE_OPTIONS
).select(["bldg_id", "sb.electric_utility", "sb.gas_utility"])

if excluded_bldg_ids:
    utility_assignment = utility_assignment.filter(
        ~pl.col("bldg_id").is_in(excluded_bldg_ids)
    )

# Ensure row counts match
n_metadata = metadata.select(pl.len()).collect().row(0)[0]
n_utility = utility_assignment.select(pl.len()).collect().row(0)[0]
if n_metadata != n_utility:
    raise ValueError(
        f"Row count mismatch: metadata has {n_metadata} rows, "
        f"utility_assignment has {n_utility} rows."
    )

# Join on bldg_id; inner join so we only keep matching rows
metadata_with_utility = metadata.join(utility_assignment, on="bldg_id", how="inner")
n_joined = metadata_with_utility.select(pl.len()).collect().row(0)[0]
if n_joined != n_metadata:
    raise ValueError(
        f"Non-matching bldg_id's: inner join produced {n_joined} rows "
        f"but metadata has {n_metadata} rows (expected equal)."
    )

# Display names from assign_utility_ny CONFIGS (std_name -> state_name)
UTILITY_DISPLAY_NAME = {
    "bath": "Bath Electric Gas and Water",
    "cenhud": "Central Hudson Gas and Electric",
    "chautauqua": "Chautauqua Utilities, Inc.",
    "coned": "Consolidated Edison",
    "corning": "Corning Natural Gas",
    "fillmore": "Fillmore Gas Company",
    "kedny": "National Grid - NYC",
    "kedli": "National Grid - Long Island",
    "nimo": "National Grid",
    "none": "None",
    "nfg": "National Fuel Gas Distribution",
    "nyseg": "NYS Electric and Gas",
    "or": "Orange and Rockland Utilities",
    "psegli": "Long Island Power Authority",
    "reserve": "Reserve Gas Company",
    "rge": "Rochester Gas and Electric",
    "stlaw": "St. Lawrence Gas",
    "valley": "Valley Energy",
    "woodhull": "Woodhull Municipal Gas Company",
}
```

## By Electric Utility
```{python}
by_electric = (
    metadata_with_utility.group_by("sb.electric_utility")
    .agg(
        pl.len().alias("total"),
        pl.col("postprocess_group.has_hp").eq(False).sum().alias("no_hp"),
    )
    .with_columns((pl.col("no_hp") / pl.col("total") * 100).alias("pct_no_hp"))
    .collect()
)
total_buildings_electric = by_electric["total"].sum()
print("Missing HP by Electric Utility:")
for row in by_electric.iter_rows(named=True):
    name = UTILITY_DISPLAY_NAME.get(row["sb.electric_utility"], row["sb.electric_utility"])
    pct_of_total = row["total"] / total_buildings_electric * 100
    print(
        f"{name}: total={row['total']} ({pct_of_total:.1f}% of total buildings), "
        f"no HP={row['no_hp']}, {row['pct_no_hp']:.2f}%"
    )
```

## By Gas Utility
```{python}
by_gas = (
    metadata_with_utility.group_by("sb.gas_utility")
    .agg(
        pl.len().alias("total"),
        pl.col("postprocess_group.has_hp").eq(False).sum().alias("no_hp"),
    )
    .with_columns((pl.col("no_hp") / pl.col("total") * 100).alias("pct_no_hp"))
    .collect()
)
total_buildings_gas = by_gas["total"].sum()
print("Missing HP by Gas Utility:")
for row in by_gas.iter_rows(named=True):
    name = UTILITY_DISPLAY_NAME.get(row["sb.gas_utility"], row["sb.gas_utility"])
    pct_of_total = row["total"] / total_buildings_gas * 100
    print(
        f"{name}: total={row['total']} ({pct_of_total:.1f}% of total buildings), "
        f"no HP={row['no_hp']}, {row['pct_no_hp']:.2f}%"
    )
```

### Count total number of customers without HP by building type
```{python}
col_bldg = pl.col("in.geometry_building_type_height")
stories_column = pl.col("in.geometry_story_bin")
building_type_group = (
    pl.when(col_bldg.str.contains("Single-Family", literal=True))
    .then(pl.lit("Single-Family"))
    .when(
        col_bldg.str.contains("Multifamily", literal=True)
        & stories_column.str.contains("8+", literal=True)
    )
    .then(pl.lit("Multifamily high-rise"))
    .when(
        col_bldg.str.contains("Multifamily", literal=True)
        & stories_column.str.contains("<8", literal=True)
    )
    .then(pl.lit("Multifamily low-rise"))
    .when(
        col_bldg.str.contains("Mobile Home", literal=True)
    )
    .then(pl.lit("Mobile Home"))
    .otherwise(pl.lit("Other"))
)

# Ensure the building type groups partition all rows: each row in exactly one category
_partition_counts = (
    metadata_with_utility.with_columns(building_type_group.alias("_bt"))
    .group_by("_bt")
    .agg(pl.len().alias("_n"))
    .collect()
)
_n_in_groups = _partition_counts["_n"].sum()
if _n_in_groups != n_joined:
    raise ValueError(
        f"Building type groups do not partition rows: sum of group counts "
        f"({_n_in_groups}) != total rows ({n_joined})."
    )

# Print results
building_type_order = [
    "Single-Family",
    "Multifamily low-rise",
    "Multifamily high-rise",
    "Mobile Home",
    "Other",
]

by_building_type = (
    metadata_with_utility.with_columns(building_type_group.alias("building_type_group"))
    .group_by("building_type_group")
    .agg(
        pl.len().alias("total"),
        pl.col("postprocess_group.has_hp").eq(False).sum().alias("no_hp"),
    )
    .with_columns((pl.col("no_hp") / pl.col("total") * 100).alias("pct_no_hp"))
    .collect()
)
by_building_type = by_building_type.sort(
    pl.col("building_type_group").replace(
        {name: i for i, name in enumerate(building_type_order)}
    )
)
total_buildings = by_building_type["total"].sum()
print("Missing HP by building type:")
for row in by_building_type.iter_rows(named=True):
    pct_of_total = row["total"] / total_buildings * 100
    print(
        f"{row['building_type_group']}: count={row['total']} ({pct_of_total:.1f}% of total buildings), "
        f"no HP={row['no_hp']}, {row['pct_no_hp']:.2f}%"
    )
```
