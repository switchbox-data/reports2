---
title: Peoples Gas Construction Impact Analysis

toc: true
reference-location: margin
fig-cap-location: bottom
execute:
  echo: false
appendix-style: default
citation-location: document
citation:
  container-title: Switchbox

format:
  html:
    page-layout: full
---

```{python}
import geopandas as gpd
import pandas as pd
import numpy as np
from pathlib import Path
from datetime import datetime
import polars as pl
import folium
import matplotlib.pyplot as plt
from IPython.display import display, HTML
# Set paths
data_dir = Path('../data')
geo_data_dir = data_dir / 'geo_data'
outputs_dir = data_dir / 'outputs'
outputs_dir.mkdir(parents=True, exist_ok=True)  # Ensure outputs directory exists
utils_dir = Path('../utils')

pd.set_option('display.max_columns', None)


```

```{python}
# Load summary data based on aggregation level

geojson_files = sorted(outputs_dir.glob(
    'peoplesgas_with_buildings_streets_block_*.geojson'))
print(f"Loading block-level data...")

if not geojson_files:
    raise FileNotFoundError(
        f"No summary GeoJSON files found for ANALYSIS_LEVEL='block'. Run geo_data_cleaning.qmd first.")

latest_geojson = geojson_files[-1]
pg_summary = gpd.read_file(latest_geojson)
pg_summary = pg_summary[pg_summary.geometry.notnull()].reset_index(drop=True)

int_cols = [
    'total_parcels', 'non_vacant_parcels', 'sf_parcels', 'mf_parcels',
    'commercial_parcels', 'industrial_parcels', 'mixed_use_parcels',
    'total_residential_units', 'mf_units'
]

for col in int_cols:
    if col in pg_summary.columns:
        pg_summary[col] = pg_summary[col].fillna(0)

print(f"Loaded: {latest_geojson.name}")

print(f"  {len(pg_summary):,} block segments")
# print(f"  Unique construction polygons: {pg_summary['OBJECTID'].nunique():,}")
print(f"  Unique city blocks: {pg_summary['geoid10'].nunique():,}")

# Define unit label for consistent use in print statements
unit_label = "blocks"

```


```{python}
# Read from the first sheet of the Google Sheet using polars
# Use export URL format instead of edit URL
gsheet_url = "https://docs.google.com/spreadsheets/d/1xxa47dClvp0rosZhUP1R7790CNXMLSD_0ExrPccR3p0/export?format=csv&gid=0"

prp_df = pl.read_csv(gsheet_url)

prp_df

```


```{python}
# cost estimates
cost_lpp_mile = prp_df.filter(pl.col("variable") == "cost_lpp_mile")["value"][0]
cost_lpp_mile

cost_elec_sf = prp_df.filter(pl.col("variable") == "cost_elec_sf")["value"][0]
cost_elec_mf = prp_df.filter(pl.col("variable") == "cost_elec_mf")["value"][0]
cost_decomm_mile = prp_df.filter(pl.col("variable") == "main_retire_cost_mile")["value"][0]
```

```{python}
# | echo: false
# Ensure all cost variables are numeric (float)
cost_lpp_mile = float(cost_lpp_mile)
cost_decomm_mile = float(cost_decomm_mile)
cost_elec_sf = float(cost_elec_sf)
cost_elec_mf = float(cost_elec_mf)
cost_elec_comm = 50000  # placeholder value

pg_summary["prp_cost"] = pg_summary["street_miles"] * cost_lpp_mile

pg_summary["elec_sf_cost"] = pg_summary["sf_parcels"] * cost_elec_sf
pg_summary["elec_mf_cost"] = pg_summary["mf_units"] * cost_elec_mf
pg_summary["elec_comm_cost"] = pg_summary["commercial_parcels"] * cost_elec_comm

pg_summary["elec_cost_total"] = pg_summary["elec_sf_cost"] + \
    pg_summary["elec_mf_cost"] + pg_summary["elec_comm_cost"]

pg_summary["elec_cost_total_w_decomm"] = pg_summary["elec_cost_total"] + \
    pg_summary["street_miles"] * cost_decomm_mile


pg_summary["pct_residential"] = (
    pg_summary["sf_parcels"] + pg_summary["mf_parcels"]) / pg_summary["non_vacant_parcels"]

pg_summary["comm_ind_total_count"] = pg_summary["commercial_parcels"] + \
    pg_summary["industrial_parcels"]

pg_summary["comm_ind_flag"] = pg_summary["comm_ind_total_count"] > 0

pg_summary["ind_flag"] = pg_summary["industrial_parcels"] > 0

pg_summary["comm_flag"] = pg_summary["commercial_parcels"] > 1

pg_summary["npa_over_prp"] = pg_summary["elec_cost_total"] / \
    pg_summary["prp_cost"]


pg_summary["npa_over_prp_w_decomm"] = pg_summary["elec_cost_total_w_decomm"] / \
    pg_summary["prp_cost"]


# bin the npa_over_prp values
pg_summary["comp_cost_discrete"] = pg_summary["npa_over_prp"].apply(
    lambda x: ("50 %" if x < 0.5 else "50-100 %" if 0.5 <= x < 1 else "100-150 %" if 1 <=
               x < 1.5 else "150-200 %" if 1.5 <= x < 2 else "> 200 %")
)

pg_summary["comp_cost_discrete_res_only"] = pg_summary["npa_over_prp"].apply(
    lambda x: ("50 %" if x < 0.5 else "50-100 %" if 0.5 <= x < 1 else "100-150 %" if 1 <=
               x < 1.5 else "150-200 %" if 1.5 <= x < 2 else "> 200 %")
)
# Overwrite comp_cost_discrete where ind_flag is True
pg_summary.loc[pg_summary["ind_flag"], "comp_cost_discrete"] = "not eligible"

pg_summary.loc[pg_summary["comm_ind_flag"],
               "comp_cost_discrete_res_only"] = "not eligible"


# bin the npa_over_prp_w_decomm values
pg_summary["comp_cost_discrete_w_decomm"] = pg_summary["npa_over_prp_w_decomm"].apply(
    lambda x: ("50 %" if x < 0.5 else "50-100 %" if 0.5 <= x < 1 else "100-150 %" if 1 <=
               x < 1.5 else "150-200 %" if 1.5 <= x < 2 else "> 200 %")
)

# Overwrite comp_cost_discrete_w_decomm where ind_flag is True
pg_summary.loc[pg_summary["ind_flag"],
               "comp_cost_discrete_w_decomm"] = "not eligible"

pg_summary.loc[pg_summary["comm_ind_flag"],
               "comp_cost_discrete_w_decomm"] = "not eligible"
```

```{python}
pg_summary["comp_cost_discrete_w_decomm"]
```

# Export the pg_summary GeoDataFrame to GeoJSON
# (Export moved to after diagnostic calculations - see below)

# Summary stats no decommissioning costs
```{python}

# Calculate the percent where npa_over_prp > 1
num_gt_1 = (pg_summary['npa_over_prp'] > 1).sum()
total_units = len(pg_summary)
percent_gt_1 = (num_gt_1 / total_units) * 100

print(f"{percent_gt_1:.1f}% of blocks have npa_over_prp > 1")

```

## Commercial and industrial parcels
```{python}

# Calculate the percent where comm_ind_flag == False
num_comm_ind_false = (pg_summary['comm_ind_flag'] == False).sum()
percent_comm_ind_false = (num_comm_ind_false / len(pg_summary)) * 100
print(f"{percent_comm_ind_false:.1f}% of {unit_label} have comm_ind_flag == False")

```

```{python}
# Calculate the percent where npa_over_prp > 1 and com_ind_flag == False
mask = (pg_summary["npa_over_prp"] > 1) * (pg_summary["comm_ind_flag"] == False)
percent_gt_1_and_comm_ind_false = (mask.sum() / len(pg_summary)) * 100
print(f"{percent_gt_1_and_comm_ind_false:.1f}% of {unit_label} have npa_over_prp > 1 and no commercial or industrial parcels")
```

## Industrial only

```{python}
# Calculate the percent where npa_over_prp > 1 and ind_flag == False
mask_ind = (pg_summary['npa_over_prp'] > 1) & (pg_summary['ind_flag'] == False)
percent_gt_1_and_ind_false = (mask_ind.sum() / len(pg_summary)) * 100
print(f"{percent_gt_1_and_ind_false:.1f}% of {unit_label} have npa_over_prp > 1 and ind_flag == False")
```

# Summary stats with decommissioning costs
```{python}
# Calculate the percent where npa_over_prp_w_decomm > 1 (with _dc suffix)
num_gt_1_dc = (pg_summary['npa_over_prp_w_decomm'] > 1).sum()
total_units_dc = len(pg_summary)
percent_gt_1_dc = (num_gt_1_dc / total_units_dc) * 100

print(f"{percent_gt_1_dc:.1f}% of {unit_label} have npa_over_prp > 1")

```

## Commercial and industrial parcels


```{python}
# Calculate the percent where npa_over_prp > 1 and com_ind_flag == False (with _dc suffix)
mask_dc = (pg_summary["npa_over_prp_w_decomm"] > 1) * (pg_summary["comm_ind_flag"] == False)
percent_gt_1_and_comm_ind_false_dc = (mask_dc.sum() / len(pg_summary)) * 100
print(f"{percent_gt_1_and_comm_ind_false_dc:.1f}% of {unit_label} have npa_over_prp > 1 and no commercial or industrial parcels")
```



 ## Industrial only



```{python}
# Calculate the percent where npa_over_prp > 1 and ind_flag == False (with _dc suffix)
mask_ind_dc = (pg_summary['npa_over_prp_w_decomm'] > 1) & (pg_summary['ind_flag'] == False)
num_gt_1_and_ind_false_dc = mask_ind_dc.sum()
percent_gt_1_and_ind_false_dc = (num_gt_1_and_ind_false_dc / len(pg_summary)) * 100
print(f"{percent_gt_1_and_ind_false_dc:.1f}% of {unit_label} have npa_over_prp > 1 and ind_flag == False")
```

# Print summary statistics - no decommissioning costs
```{python}
print(f"{percent_gt_1:.1f}% of {unit_label} have npa_over_prp > 1")
print(f"{percent_comm_ind_false:.1f}% of {unit_label} have comm_ind_flag == False")
print(f"{percent_gt_1_and_comm_ind_false:.1f}% of {unit_label} have npa_over_prp > 1 and no commercial or industrial parcels")
print(f"{percent_gt_1_and_ind_false:.1f}% of {unit_label} have npa_over_prp > 1 and ind_flag == False")
```

# Print summary statistics - with decommissioning costs
```{python}
print(f"{percent_gt_1_dc:.1f}% of {unit_label} have npa_over_prp > 1")
print(f"{percent_gt_1_and_comm_ind_false_dc:.1f}% of {unit_label} have npa_over_prp > 1 and no commercial or industrial parcels")
print(f"{percent_gt_1_and_ind_false_dc:.1f}% of {unit_label} have npa_over_prp > 1 and ind_flag == False")
```

```{python}
def plot_pg_polygons_map(pg_summary, fill_col, discrete=False, cmap="viridis", legend=True, color_dict=None, title=None):
    """
    Create an interactive Folium map of Peoples Gas construction polygons, coloring by the specified column.

    Args:
        pg_summary: GeoDataFrame of construction polygons with attributes.
        fill_col (str): Column to use for fill color.
        discrete (bool): Whether to treat fill_col as discrete (categorical) or continuous.
        cmap (str): Colormap to use for continuous fill (e.g., 'viridis', 'YlOrRd', 'RdYlGn').
        legend (bool): Whether to show the legend.
        color_dict (dict, optional): For discrete data, a dictionary mapping category values to hex colors.
                                     If None, colors are automatically assigned.
        title (str, optional): Title to display at the top of the map.

    Returns:
        folium.Map: Interactive Folium map
    """
    import folium
    import branca.colormap as cm
    import matplotlib.pyplot as plt
    import matplotlib.colors as mcolors

    # Reproject to WGS84 for Folium and filter out missing geometries
    pg_map = pg_summary[pg_summary.geometry.notna()].to_crs(epsg=4326)

    # Calculate the center of the map
    bounds = pg_map.total_bounds
    center_lat = (bounds[1] + bounds[3]) / 2
    center_lon = (bounds[0] + bounds[2]) / 2

    # Create the base map
    m = folium.Map(
        location=[center_lat, center_lon],
        zoom_start=11,
        tiles='cartodbpositron'
    )

    # Add title if provided
    if title is not None:
        title_html = f'''
        <div style="position: fixed; top: 10px; left: 50px; width: auto; height: auto;
        background-color: white; border:2px solid grey; z-index:9999; font-size:18px;
        font-weight: bold; padding: 10px 20px;">
        {title}
        </div>
        '''
        m.get_root().html.add_child(folium.Element(title_html))

    if discrete:
        # Handle categorical data
        categories = pg_map[fill_col].dropna().unique()
        categories_sorted = sorted(categories)

        # Use provided color_dict or create automatic color palette
        if color_dict is not None:
            category_colors = color_dict
        else:
            # Create automatic color palette
            color_palette = plt.get_cmap("tab10", len(categories_sorted))
            category_colors = {cat: mcolors.rgb2hex(color_palette(i)) for i, cat in enumerate(categories_sorted)}

        # Add each polygon with its category color
        for idx, row in pg_map.iterrows():
            cat_value = row[fill_col]
            if pd.notna(cat_value) and row.geometry is not None:
                color = category_colors.get(cat_value, '#gray')

                # Create popup with all relevant info
                popup_html = f"<b>{fill_col}:</b> {cat_value}<br>"
                for col in ['street_miles', 'sf_parcels', 'mf_units', 'commercial_parcels', 'industrial_parcels']:
                    if col in row.index:
                        popup_html += f"<b>{col}:</b> {row[col]}<br>"

                folium.GeoJson(
                    row.geometry,
                    style_function=lambda x, color=color: {
                        'fillColor': color,
                        'color': 'black',
                        'weight': 1,
                        'fillOpacity': 0.6
                    },
                    popup=folium.Popup(popup_html, max_width=300)
                ).add_to(m)

        # Add legend for discrete values
        if legend:
            legend_html = f'''
            <div style="position: fixed; top: 10px; right: 10px; width: 200px; height: auto;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px; padding: 10px">
            <p style="margin-bottom: 5px;"><b>{fill_col}</b></p>
            '''
            for cat in categories_sorted:
                color = category_colors.get(cat, '#gray')
                legend_html += f'<p style="margin: 3px 0;"><span style="background-color:{color}; width: 20px; height: 20px; display: inline-block; border: 1px solid black;"></span> {cat}</p>'
            legend_html += '</div>'
            m.get_root().html.add_child(folium.Element(legend_html))
    else:
        # Handle continuous data
        vmin = pg_map[fill_col].min()
        vmax = pg_map[fill_col].max()

        # Create colormap - convert matplotlib colormap to hex colors
        mpl_cmap = plt.get_cmap(cmap)
        colors_list = [mcolors.rgb2hex(mpl_cmap(i/255)) for i in range(256)]

        colormap = cm.LinearColormap(
            colors=colors_list,
            vmin=vmin,
            vmax=vmax,
            caption=fill_col
        )

        # Add each polygon with its color based on value
        for idx, row in pg_map.iterrows():
            value = row[fill_col]
            if pd.notna(value) and row.geometry is not None:
                color = colormap(value)

                # Create popup with all relevant info
                popup_html = f"<b>{fill_col}:</b> {value:.2f}<br>"
                for col in ['street_miles', 'sf_parcels', 'mf_units', 'commercial_parcels', 'industrial_parcels', 'prp_cost', 'elec_cost_total']:
                    if col in row.index and pd.notna(row[col]):
                        popup_html += f"<b>{col}:</b> {row[col]:.2f}<br>"

                folium.GeoJson(
                    row.geometry,
                    style_function=lambda x, color=color: {
                        'fillColor': color,
                        'color': 'black',
                        'weight': 1,
                        'fillOpacity': 0.6
                    },
                    popup=folium.Popup(popup_html, max_width=300)
                ).add_to(m)

        # Add colormap legend
        if legend:
            colormap.add_to(m)

    # Add layer control
    folium.LayerControl().add_to(m)

    return m
```

# Street miles

```{python}
# Create interactive map showing count of street miles (continuous)
map_title = f"Street miles in {unit_label}"
m = plot_pg_polygons_map(pg_summary, 'street_miles', discrete=False, cmap='YlOrRd', title=map_title)
m
```

```{python}
# Create interactive map showing count of street miles < 0.1mi
filtered_data = pg_summary[pg_summary["street_miles"] < 0.1]
map_title = f"Street miles in {unit_label} (< 0.1 mi)"
m = plot_pg_polygons_map(filtered_data, "street_miles", discrete=False, cmap="YlOrRd", title=map_title)
m
```

# Industrial flag

```{python}
#| label: fig-ind-flag
#| fig-cap: "Industrial flag"
#| fig-width: 10
#| fig-height: 10

# Create interactive map showing industrial flag (discrete/categorical)
map_title = f"{unit_label.capitalize()} with 1 or more industrial parcels"
m = plot_pg_polygons_map(pg_summary, 'ind_flag', discrete=True, color_dict={
                         True: '#ff0000', False: '#0000ff'}, title=map_title)
m
```

# PRP and LPP costs without decommissioning costs
```{python}
# | label: fig-comp-cost-discrete
# | fig-cap: "Comparison of PRP and LPP costs"
# | fig-width: 10
# | fig-height: 10

# Create interactive map showing cost comparison (discrete/categorical)
filtered_data = pg_summary[np.isfinite(pg_summary['npa_over_prp'])]
m = plot_pg_polygons_map(
    filtered_data,
    'comp_cost_discrete',
    discrete=True,
    color_dict={
        "50 %": "#FC9706",
        "50-100 %": "#68BED8",
        "100-150 %": "#A0AF12",
        "150-200 %": "#546800",
        "> 200 %": "#546800",
        "not eligible": "#8e8b7c"
    }
)
m
```

### 100% residential areas only

```{python}
# | label: fig-comp-cost-discrete-res-only
# | fig-cap: "Comparison of PRP and LPP costs (residential only)"
# | fig-width: 10
# | fig-height: 10

# Create interactive map showing cost comparison for residential only
filtered_data = pg_summary[np.isfinite(pg_summary['npa_over_prp'])]
m = plot_pg_polygons_map(
    filtered_data,
    'comp_cost_discrete_res_only',
    discrete=True,
    color_dict={
        "50 %": "#FC9706",
        "50-100 %": "#68BED8",
        "100-150 %": "#A0AF12",
        "150-200 %": "#546800",
        "> 200 %": "#546800",
        "not eligible": "#8e8b7c"
    }
)
m
```

# Residential and Commercial (exclude industrial)

```{python}
# | label: fig-pct-residential
# | fig-cap: "Percent residential"
# | fig-width: 10
# | fig-height: 10

# Create interactive map showing percent residential (continuous)
filtered_data = pg_summary[(pg_summary['npa_over_prp'] > 10) & (pg_summary['ind_flag'] == False)]
map_title = f"{unit_label.capitalize()} with npa_over_prp > 10 and no industrial parcels"
m = plot_pg_polygons_map(
    filtered_data,
    'pct_residential',
    discrete=False,
    title=map_title
)
m
```



# PRP and LPP costs with decommissioning costs
```{python}
# | label: fig-comp-cost-discrete-w-decomm
# | fig-cap: "Comparison of PRP and LPP costs with decommissioning"
# | fig-width: 10
# | fig-height: 10

# Create interactive map showing cost comparison with decommissioning
filtered_data = pg_summary[np.isfinite(pg_summary['npa_over_prp_w_decomm'])]
m = plot_pg_polygons_map(
    filtered_data,
    'comp_cost_discrete_w_decomm',
    discrete=True,
    color_dict={
        "50 %": "#FC9706",
        "50-100 %": "#68BED8",
        "100-150 %": "#A0AF12",
        "150-200 %": "#546800",
        "> 200 %": "#546800",
        "not eligible": "#8e8b7c"
    }
)
m
```

### 100% residential areas only

```{python}
# | label: fig-comp-cost-discrete-w-decomm-res-only
# | fig-cap: "Comparison of PRP and LPP costs for construction polygons with decommissioning costs"
# | fig-width: 10
# | fig-height: 10

# # Create interactive map showing industrial flag (discrete/categorical)
# m = plot_pg_polygons_map(
#     pg_summary[np.isfinite(pg_summary['lpp_over_npa_w_decomm'])],
#     'comp_cost_discrete_w_decomm_res_only',
#     discrete=True,
#     color_dict={
#         "PRP cheaper": "#FC9706",
#         "equal": "#68BED8",
#         "1-2 x": "#A0AF12",
#         "> 2": "#546800",
#         "not eligible": "#8e8b7c"
#     }
# )
# m
# m
```

# Residential and Commercial (exclude industrial)

```{python}
# | label: fig-pct-residential-w-decomm
# | fig-cap: "Percent residential (with decommissioning)"
# | fig-width: 10
# | fig-height: 10

# Create interactive map showing percent residential (continuous)
filtered_data = pg_summary[(pg_summary['npa_over_prp'] > 10) & (pg_summary['ind_flag'] == False)]
map_title = f"{unit_label.capitalize()} with npa_over_prp > 10 and no industrial parcels"
m = plot_pg_polygons_map(
    filtered_data,
    'pct_residential',
    discrete=False,
    title=map_title
)
m
```



# Histograms
```{python}

# Filter to only finite values
valid_data = pg_summary[np.isfinite(pg_summary['npa_over_prp'])]['npa_over_prp']

plt.figure(figsize=(8, 6))
plt.hist(valid_data, bins=30, color='skyblue', edgecolor='black')
plt.xlabel('npa_over_prp')
plt.ylabel('Count')
plt.title('Histogram of npa_over_prp (finite values only)')
plt.grid(True)
plt.show()
```

```{python}

plt.figure(figsize=(8, 6))
plt.hist(pg_summary['comm_ind_total_count'], bins=30, color='orange', edgecolor='black')
plt.xlabel('comm_ind_total_count')
plt.ylabel('Count')
plt.title('Histogram of comm_ind_total_count')
plt.grid(True)
plt.show()
```


```{python}
plt.figure(figsize=(8, 6))
plt.hist(pg_summary['pct_residential'], bins=100, color='green', edgecolor='black')
plt.xlabel('pct_residential')
plt.ylabel('Count')
plt.title('Histogram of pct_residential')
plt.grid(True)
plt.show()
```



```{python}
plt.figure(figsize=(8, 6))
plt.hist(pg_summary['street_miles'], bins=100, color='blue', edgecolor='black')
plt.xlabel('street_miles')
plt.ylabel('Count')
plt.title('Histogram of street_miles')
plt.grid(True)
plt.show()
```

## Diagnostic Histograms

```{python}
# Calculate block perimeter and area
# Ensure we're using a projected CRS for accurate measurements
# Use UTM Zone 16N (EPSG:32616) which uses meters, matching the rest of the codebase
if pg_summary.crs is None or pg_summary.crs.is_geographic:
    pg_summary_projected = pg_summary.to_crs(epsg=32616)
else:
    pg_summary_projected = pg_summary.to_crs(epsg=32616)

# Calculate perimeter in meters, then convert to miles
# UTM Zone 16N uses meters as the unit
pg_summary['block_perimeter_miles'] = pg_summary_projected.geometry.length / 1609.34  # meters to miles

# Calculate area in square meters, then convert to square kilometers
# UTM Zone 16N uses meters, so area is in square meters
pg_summary['block_area_sq_km'] = pg_summary_projected.geometry.area / 1_000_000  # sq meters to sq kilometers

# Calculate ratio of street miles to block perimeter (inverted)
pg_summary['perimeter_to_street_miles_ratio'] = pg_summary['street_miles'] / pg_summary['block_perimeter_miles']

# Calculate total parcels per area (parcels per square kilometer)
pg_summary['parcels_per_sq_km'] = pg_summary['non_vacant_parcels'] / pg_summary['block_area_sq_km']

# Diagnostic: Print sample values to verify units
print("Sample diagnostic values (first 5 rows):")
print(pg_summary[['block_perimeter_miles', 'street_miles', 'perimeter_to_street_miles_ratio',
                  'block_area_sq_km', 'parcels_per_sq_km']].head())
print(f"\nBlock perimeter stats: min={pg_summary['block_perimeter_miles'].min():.4f}, "
      f"max={pg_summary['block_perimeter_miles'].max():.4f}, "
      f"median={pg_summary['block_perimeter_miles'].median():.4f} miles")
print(f"Street miles stats: min={pg_summary['street_miles'].min():.6f}, "
      f"max={pg_summary['street_miles'].max():.4f}, "
      f"median={pg_summary['street_miles'].median():.6f} miles")

# Filter out invalid values (infinite, NaN, or zero street_miles)
valid_perimeter_ratio = pg_summary[
    (np.isfinite(pg_summary['perimeter_to_street_miles_ratio'])) &
    (pg_summary['street_miles'] > 0)
]['perimeter_to_street_miles_ratio']

valid_parcels_density = pg_summary[
    (np.isfinite(pg_summary['parcels_per_sq_km'])) &
    (pg_summary['block_area_sq_km'] > 0)
]['parcels_per_sq_km']
```

```{python}
# Histogram: Ratio of street miles to block perimeter - split into 3 ranges
# Subset data into three groups
ratio_le_1 = valid_perimeter_ratio[valid_perimeter_ratio <= 1]
ratio_1_to_2 = valid_perimeter_ratio[(valid_perimeter_ratio > 1) & (valid_perimeter_ratio <= 2)]
ratio_gt_2 = valid_perimeter_ratio[valid_perimeter_ratio > 2]

# Plot 1: Ratio <= 1
plt.figure(figsize=(10, 6))
plt.hist(ratio_le_1, bins=30, color='steelblue', edgecolor='black', alpha=0.7)
plt.xlabel('Street Miles to Block Perimeter Ratio', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.title('Histogram of Street Miles to Block Perimeter Ratio (Ratio ≤ 1)', fontsize=14)
plt.grid(True, alpha=0.3)
if len(ratio_le_1) > 0:
    plt.axvline(ratio_le_1.median(), color='red', linestyle='--', linewidth=2, label=f'Median: {ratio_le_1.median():.2f}')
    plt.legend()
plt.show()

print(f"Summary statistics for ratio ≤ 1:")
print(f"  Count: {len(ratio_le_1):,}")
if len(ratio_le_1) > 0:
    print(f"  Mean: {ratio_le_1.mean():.2f}")
    print(f"  Median: {ratio_le_1.median():.2f}")
    print(f"  Std Dev: {ratio_le_1.std():.2f}")
    print(f"  Min: {ratio_le_1.min():.2f}")
    print(f"  Max: {ratio_le_1.max():.2f}")

# Plot 2: Ratio 1-2
plt.figure(figsize=(10, 6))
plt.hist(ratio_1_to_2, bins=30, color='steelblue', edgecolor='black', alpha=0.7)
plt.xlabel('Street Miles to Block Perimeter Ratio', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.title('Histogram of Street Miles to Block Perimeter Ratio (1 < Ratio ≤ 2)', fontsize=14)
plt.grid(True, alpha=0.3)
if len(ratio_1_to_2) > 0:
    plt.axvline(ratio_1_to_2.median(), color='red', linestyle='--', linewidth=2, label=f'Median: {ratio_1_to_2.median():.2f}')
    plt.legend()
plt.show()

print(f"\nSummary statistics for 1 < ratio ≤ 2:")
print(f"  Count: {len(ratio_1_to_2):,}")
if len(ratio_1_to_2) > 0:
    print(f"  Mean: {ratio_1_to_2.mean():.2f}")
    print(f"  Median: {ratio_1_to_2.median():.2f}")
    print(f"  Std Dev: {ratio_1_to_2.std():.2f}")
    print(f"  Min: {ratio_1_to_2.min():.2f}")
    print(f"  Max: {ratio_1_to_2.max():.2f}")

# Plot 3: Ratio > 2
plt.figure(figsize=(10, 6))
plt.hist(ratio_gt_2, bins=50, color='steelblue', edgecolor='black', alpha=0.7)
plt.xlabel('Street Miles to Block Perimeter Ratio', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.title('Histogram of Street Miles to Block Perimeter Ratio (Ratio > 2)', fontsize=14)
plt.grid(True, alpha=0.3)
if len(ratio_gt_2) > 0:
    plt.axvline(ratio_gt_2.median(), color='red', linestyle='--', linewidth=2, label=f'Median: {ratio_gt_2.median():.2f}')
    plt.legend()
plt.show()

print(f"\nSummary statistics for ratio > 2:")
print(f"  Count: {len(ratio_gt_2):,}")
if len(ratio_gt_2) > 0:
    print(f"  Mean: {ratio_gt_2.mean():.2f}")
    print(f"  Median: {ratio_gt_2.median():.2f}")
    print(f"  Std Dev: {ratio_gt_2.std():.2f}")
    print(f"  Min: {ratio_gt_2.min():.2f}")
    print(f"  Max: {ratio_gt_2.max():.2f}")

# Overall summary
print(f"\nOverall summary statistics for all ratios:")
print(f"  Total Count: {len(valid_perimeter_ratio):,}")
print(f"  Ratio ≤ 1: {len(ratio_le_1):,} ({len(ratio_le_1)/len(valid_perimeter_ratio)*100:.1f}%)")
print(f"  1 < Ratio ≤ 2: {len(ratio_1_to_2):,} ({len(ratio_1_to_2)/len(valid_perimeter_ratio)*100:.1f}%)")
print(f"  Ratio > 2: {len(ratio_gt_2):,} ({len(ratio_gt_2)/len(valid_perimeter_ratio)*100:.1f}%)")
```

```{python}
# List block_poly_id where street to perimeter ratio < 0.2
if 'block_poly_id' in pg_summary.columns:
    low_ratio_blocks = pg_summary[
        (np.isfinite(pg_summary['perimeter_to_street_miles_ratio'])) &
        (pg_summary['perimeter_to_street_miles_ratio'] < 0.2) &
        (pg_summary['block_perimeter_miles'] > 0)
    ]

    block_poly_ids = sorted(low_ratio_blocks['block_poly_id'].tolist())

    print(f"Blocks with street to perimeter ratio < 0.2: {len(block_poly_ids):,}")
    print(f"\nblock_poly_id list ({len(block_poly_ids)} blocks):")
    print(block_poly_ids)

    # Also show some details for these blocks
    if len(low_ratio_blocks) > 0:
        print(f"\nSample details (first 10 blocks):")
        print(low_ratio_blocks[['block_poly_id', 'perimeter_to_street_miles_ratio',
                                'street_miles', 'block_perimeter_miles', 'non_vacant_parcels']].head(10))
else:
    print("block_poly_id column not found in pg_summary. Available columns:")
    print(pg_summary.columns.tolist())
```

```{python}
# Histogram: Number of parcels per square kilometer
plt.figure(figsize=(10, 6))
plt.hist(valid_parcels_density, bins=50, color='coral', edgecolor='black', alpha=0.7)
plt.xlabel('Parcels per Square Kilometer', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.title('Histogram of Parcels per Square Kilometer by Block', fontsize=14)
plt.grid(True, alpha=0.3)
plt.axvline(valid_parcels_density.median(), color='red', linestyle='--', linewidth=2, label=f'Median: {valid_parcels_density.median():.0f}')
plt.legend()
plt.show()

print(f"Summary statistics for parcels per square kilometer:")
print(f"  Count: {len(valid_parcels_density):,}")
print(f"  Mean: {valid_parcels_density.mean():.0f}")
print(f"  Median: {valid_parcels_density.median():.0f}")
print(f"  Std Dev: {valid_parcels_density.std():.0f}")
print(f"  Min: {valid_parcels_density.min():.0f}")
print(f"  Max: {valid_parcels_density.max():.0f}")
```

```{python}


# Histogram: npa_over_prp_w_decomm

plt.figure(figsize=(10, 6))
series = pg_summary['npa_over_prp_w_decomm'][np.isfinite(pg_summary['npa_over_prp_w_decomm'])]
plt.hist(series, bins=50, color='coral', edgecolor='black', alpha=0.7)
plt.xlabel('npa_over_prp_w_decomm', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.title('Histogram of npa_over_prp_w_decomm', fontsize=14)
plt.grid(True, alpha=0.3)
plt.axvline(series.median(), color='red', linestyle='--', linewidth=2, label=f'Median: {series.median():.2f}')
plt.legend()
plt.show()

print(f"Summary statistics for npa_over_prp_w_decomm:")
print(f"  Count: {len(series):,}")
print(f"  Mean: {series.mean():.2f}")
print(f"  Median: {series.median():.2f}")
print(f"  Std Dev: {series.std():.2f}")
print(f"  Min: {series.min():.2f}")
print(f"  Max: {series.max():.2f}")
```


# Export the pg_summary GeoDataFrame to GeoJSON with diagnostic attributes

```{python}
# Ensure geometry is in WGS84 for export
pg_summary_export = pg_summary.to_crs(epsg=4326) if pg_summary.crs != 'EPSG:4326' else pg_summary.copy()

# Export final GeoJSON with all attributes including diagnostic metrics
output_geojson = outputs_dir / \
    f"final_peoplesgas_with_buildings_streets_block_all_{datetime.now().strftime('%Y%m%d')}.geojson"
pg_summary_export.to_file(output_geojson, driver="GeoJSON")
print(f"✅ Exported pg_summary to {output_geojson}")
print(f"   Includes diagnostic attributes: block_perimeter_miles, block_area_sq_km, perimeter_to_street_miles_ratio, parcels_per_sq_km")
print(f"   Total features: {len(pg_summary_export):,}")

# # separate layers for closed and open construction polygons
# closed_construction_polygons = pg_summary_export[pg_summary_export["status_simple"] == "closed"]
# open_construction_polygons = pg_summary_export[pg_summary_export["status_simple"] == "planned"]

# # export closed and open construction polygons to GeoJSON
# closed_construction_polygons.to_file(
#     outputs_dir / f"final_peoplesgas_with_buildings_streets_{ANALYSIS_LEVEL}_closed_{datetime.now().strftime('%Y%m%d')}.geojson", driver="GeoJSON")
# open_construction_polygons.to_file(
#     outputs_dir / f"final_peoplesgas_with_buildings_streets_{ANALYSIS_LEVEL}_open_{datetime.now().strftime('%Y%m%d')}.geojson", driver="GeoJSON")
```
