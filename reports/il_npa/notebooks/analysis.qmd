---
title: Peoples Gas Construction Impact Analysis

toc: true
reference-location: margin
fig-cap-location: bottom

appendix-style: default
citation-location: document
citation:
  container-title: Switchbox

format:
  html:
    page-layout: full
---

```{python}
import geopandas as gpd
import pandas as pd
import numpy as np
from pathlib import Path
from datetime import datetime
import polars as pl
import folium
import matplotlib.pyplot as plt
# Set paths
data_dir = Path('../data')
geo_data_dir = data_dir / 'geo_data'
utils_dir = Path('../utils')

pd.set_option('display.max_columns', None)

```

```{python}

# Find the most recent summary GeoJSON file exported from geo_data_cleaning
geojson_files = sorted(data_dir.glob('peoplesgas_with_buildings_streets_*.geojson'))


latest_geojson = geojson_files[-1]
pg_summary = gpd.read_file(latest_geojson)
pg_summary = pg_summary[pg_summary.geometry.notnull()].reset_index(drop=True)


```


```{python}
# Read from the first sheet of the Google Sheet using polars
# Use export URL format instead of edit URL
gsheet_url = "https://docs.google.com/spreadsheets/d/1xxa47dClvp0rosZhUP1R7790CNXMLSD_0ExrPccR3p0/export?format=csv&gid=0"

prp_df = pl.read_csv(gsheet_url)

prp_df

```


```{python}
#cost estimates
cost_lpp_mile = prp_df.filter(
    pl.col('variable') == 'cost_lpp_mile')['value'][0]
cost_lpp_mile

cost_elec_sf = prp_df.filter(pl.col('variable') == 'cost_elec_sf')['value'][0]
cost_elec_mf = prp_df.filter(pl.col('variable') == 'cost_elec_mf')['value'][0]

```

```{python}
# Ensure all cost variables are numeric (float)
cost_lpp_mile = float(cost_lpp_mile)
cost_elec_sf = float(cost_elec_sf)
cost_elec_mf = float(cost_elec_mf)
cost_elec_comm = 30000  # placeholder value

pg_summary['lpp_cost'] = pg_summary['street_miles'] * cost_lpp_mile

pg_summary['elec_sf_cost'] = pg_summary['sf_parcels'] * cost_elec_sf
pg_summary['elec_mf_cost'] = pg_summary['mf_units'] * cost_elec_mf
pg_summary['elec_comm_cost'] = pg_summary['commercial_parcels'] * cost_elec_comm

pg_summary['elec_cost_total'] = pg_summary['elec_sf_cost'] + \
    pg_summary['elec_mf_cost'] + pg_summary['elec_comm_cost']

pg_summary['pct_residential'] = (pg_summary['sf_parcels']
+ pg_summary['mf_parcels']) / pg_summary['total_parcels']

pg_summary['comm_ind_total_count'] = pg_summary['commercial_parcels'] + \
    pg_summary['industrial_parcels']

pg_summary['comm_ind_flag'] = pg_summary['comm_ind_total_count'] > 0

pg_summary['ind_flag'] = pg_summary['industrial_parcels'] > 1

pg_summary['comm_flag'] = pg_summary['commercial_parcels'] > 1

pg_summary['lpp_over_npa'] = pg_summary['lpp_cost'] / \
    pg_summary['elec_cost_total']

pg_summary['comp_cost_discrete'] = pg_summary['lpp_over_npa'].apply(
    lambda x: (
        "PRP cheaper" if x < 1
        else "equal" if 1 <= x <= 1.015
        else "1-2 x" if 1.015 < x < 2
        else "> 2"
    )
)
# Overwrite comp_cost_discrete where ind_flag is True
pg_summary.loc[pg_summary['ind_flag'], 'comp_cost_discrete'] = "not eligible"
```


```{python}
# Calculate the percent of polygons where npa_over_lpp > 1
num_gt_1 = (pg_summary['lpp_over_npa'] > 1).sum()
total_polygons = len(pg_summary)
percent_gt_1 = (num_gt_1 / total_polygons) * 100

print(f"{percent_gt_1:.1f}% of construction polygons have npa_over_lpp > 1")

```

# ind or comm
```{python}

# Calculate the percent of polygons where comm_ind_flag == False
num_comm_ind_false = (pg_summary['comm_ind_flag'] == False).sum()
percent_comm_ind_false = (num_comm_ind_false / len(pg_summary)) * 100
print(f"{percent_comm_ind_false:.1f}% of construction polygons have comm_ind_flag == False")

```

```{python}
# Calculate the percent of polygons where lpp_over_npa > 1 and comm_ind_flag == False
num_gt_1_and_comm_ind_false = (pg_summary['lpp_over_npa'] > 1) & (pg_summary['comm_ind_flag'] == False).sum()
percent_gt_1_and_comm_ind_false = (num_gt_1_and_comm_ind_false.sum() / len(pg_summary)) * 100
print(f"{percent_gt_1_and_comm_ind_false:.1f}% of construction polygons have lpp_over_npa > 1 and comm_ind_flag == False")
```


 # ind only


```{python}

# Calculate the percent of polygons where comm_ind_flag == False
num_ind_false = (pg_summary['ind_flag'] == False).sum()
percent_ind_false = (num_ind_false / len(pg_summary)) * 100
print(f"{percent_ind_false:.1f}% of construction polygons have ind_flag == False")

```

```{python}
# Calculate the percent of polygons where lpp_over_npa > 1 and comm_ind_flag == False
num_gt_1_and_ind_false = (pg_summary['lpp_over_npa'] > 1) & (pg_summary['ind_flag'] == False).sum()
percent_gt_1_and_ind_false = (num_gt_1_and_ind_false.sum() / len(pg_summary)) * 100
print(f"{percent_gt_1_and_ind_false:.1f}% of construction polygons have lpp_over_npa > 1 and ind_flag == False")
```



```{python}
def plot_pg_polygons_map(pg_summary, fill_col, discrete=False, cmap="viridis", legend=True, color_dict=None, title=None):
    """
    Create an interactive Folium map of Peoples Gas construction polygons, coloring by the specified column.

    Args:
        pg_summary: GeoDataFrame of construction polygons with attributes.
        fill_col (str): Column to use for fill color.
        discrete (bool): Whether to treat fill_col as discrete (categorical) or continuous.
        cmap (str): Colormap to use for continuous fill (e.g., 'viridis', 'YlOrRd', 'RdYlGn').
        legend (bool): Whether to show the legend.
        color_dict (dict, optional): For discrete data, a dictionary mapping category values to hex colors.
                                     If None, colors are automatically assigned.
        title (str, optional): Title to display at the top of the map.

    Returns:
        folium.Map: Interactive Folium map
    """
    import folium
    import branca.colormap as cm
    import matplotlib.pyplot as plt
    import matplotlib.colors as mcolors

    # Reproject to WGS84 for Folium and filter out missing geometries
    pg_map = pg_summary[pg_summary.geometry.notna()].to_crs(epsg=4326)

    # Calculate the center of the map
    bounds = pg_map.total_bounds
    center_lat = (bounds[1] + bounds[3]) / 2
    center_lon = (bounds[0] + bounds[2]) / 2

    # Create the base map
    m = folium.Map(
        location=[center_lat, center_lon],
        zoom_start=11,
        tiles='cartodbpositron'
    )

    # Add title if provided
    if title is not None:
        title_html = f'''
        <div style="position: fixed; top: 10px; left: 50px; width: auto; height: auto;
        background-color: white; border:2px solid grey; z-index:9999; font-size:18px;
        font-weight: bold; padding: 10px 20px;">
        {title}
        </div>
        '''
        m.get_root().html.add_child(folium.Element(title_html))

    if discrete:
        # Handle categorical data
        categories = pg_map[fill_col].dropna().unique()
        categories_sorted = sorted(categories)

        # Use provided color_dict or create automatic color palette
        if color_dict is not None:
            category_colors = color_dict
        else:
            # Create automatic color palette
            color_palette = plt.get_cmap("tab10", len(categories_sorted))
            category_colors = {cat: mcolors.rgb2hex(color_palette(i)) for i, cat in enumerate(categories_sorted)}

        # Add each polygon with its category color
        for idx, row in pg_map.iterrows():
            cat_value = row[fill_col]
            if pd.notna(cat_value) and row.geometry is not None:
                color = category_colors.get(cat_value, '#gray')

                # Create popup with all relevant info
                popup_html = f"<b>{fill_col}:</b> {cat_value}<br>"
                for col in ['street_miles', 'sf_parcels', 'mf_units', 'commercial_parcels', 'industrial_parcels']:
                    if col in row.index:
                        popup_html += f"<b>{col}:</b> {row[col]}<br>"

                folium.GeoJson(
                    row.geometry,
                    style_function=lambda x, color=color: {
                        'fillColor': color,
                        'color': 'black',
                        'weight': 1,
                        'fillOpacity': 0.6
                    },
                    popup=folium.Popup(popup_html, max_width=300)
                ).add_to(m)

        # Add legend for discrete values
        if legend:
            legend_html = f'''
            <div style="position: fixed; top: 10px; right: 10px; width: 200px; height: auto;
            background-color: white; border:2px solid grey; z-index:9999; font-size:14px; padding: 10px">
            <p style="margin-bottom: 5px;"><b>{fill_col}</b></p>
            '''
            for cat in categories_sorted:
                color = category_colors.get(cat, '#gray')
                legend_html += f'<p style="margin: 3px 0;"><span style="background-color:{color}; width: 20px; height: 20px; display: inline-block; border: 1px solid black;"></span> {cat}</p>'
            legend_html += '</div>'
            m.get_root().html.add_child(folium.Element(legend_html))
    else:
        # Handle continuous data
        vmin = pg_map[fill_col].min()
        vmax = pg_map[fill_col].max()

        # Create colormap - convert matplotlib colormap to hex colors
        mpl_cmap = plt.get_cmap(cmap)
        colors_list = [mcolors.rgb2hex(mpl_cmap(i/255)) for i in range(256)]

        colormap = cm.LinearColormap(
            colors=colors_list,
            vmin=vmin,
            vmax=vmax,
            caption=fill_col
        )

        # Add each polygon with its color based on value
        for idx, row in pg_map.iterrows():
            value = row[fill_col]
            if pd.notna(value) and row.geometry is not None:
                color = colormap(value)

                # Create popup with all relevant info
                popup_html = f"<b>{fill_col}:</b> {value:.2f}<br>"
                for col in ['street_miles', 'sf_parcels', 'mf_units', 'commercial_parcels', 'industrial_parcels', 'lpp_cost', 'elec_cost_total']:
                    if col in row.index and pd.notna(row[col]):
                        popup_html += f"<b>{col}:</b> {row[col]:.2f}<br>"

                folium.GeoJson(
                    row.geometry,
                    style_function=lambda x, color=color: {
                        'fillColor': color,
                        'color': 'black',
                        'weight': 1,
                        'fillOpacity': 0.6
                    },
                    popup=folium.Popup(popup_html, max_width=300)
                ).add_to(m)

        # Add colormap legend
        if legend:
            colormap.add_to(m)

    # Add layer control
    folium.LayerControl().add_to(m)

    return m
```

```{python}
# Create interactive map showing industrial parcels (continuous)
m = plot_pg_polygons_map(pg_summary, 'industrial_parcels', discrete=False, cmap='YlOrRd')
m
```

```{python}
#| label: fig-ind-flag
#| fig-cap: "Industrial flag for construction polygons"
#| fig-width: 10
#| fig-height: 10

# Create interactive map showing industrial flag (discrete/categorical)
m = plot_pg_polygons_map(pg_summary, 'ind_flag', discrete=True, color_dict={
                         True: '#ff0000', False: '#0000ff'}, title = "Construction polygons with more than 1 industrial parcel")
m
```


```{python}
# | label: fig-comp-cost-discrete
# | fig-cap: "Comparison of PRP and LPP costs for construction polygons"
# | fig-width: 10
# | fig-height: 10

# Create interactive map showing industrial flag (discrete/categorical)
m = plot_pg_polygons_map(
    pg_summary[np.isfinite(pg_summary['lpp_over_npa'])],
    'comp_cost_discrete',
    discrete=True,
    color_dict={
        "PRP cheaper": "#FC9706",
        "equal": "#68BED8",
        "1-2 x": "#A0AF12",
        "> 2": "#546800",
        "not eligible": "#8e8b7c"
    }
)
m
m
```

```{python}
# | label: fig-pct-residential
# | fig-cap: "Comparison of PRP and LPP costs for construction polygons"
# | fig-width: 10
# | fig-height: 10

# Create interactive map showing industrial flag (discrete/categorical)
m = plot_pg_polygons_map(
    pg_summary[(pg_summary['lpp_over_npa'] > 10) & (pg_summary['ind_flag'] == False)],
    'pct_residential',
    discrete=False,
    title = "Construction polygons with lpp_over_npa > 10 and no industrial parcels"
)
m
```


```{python}

# Filter to only finite values
valid_data = pg_summary[np.isfinite(pg_summary['lpp_over_npa'])]['lpp_over_npa']

plt.figure(figsize=(8, 6))
plt.hist(valid_data, bins=30, color='skyblue', edgecolor='black')
plt.xlabel('lpp_over_npa')
plt.ylabel('Count')
plt.title('Histogram of lpp_over_npa (finite values only)')
plt.grid(True)
plt.show()
```

```{python}

plt.figure(figsize=(8, 6))
plt.hist(pg_summary['comm_ind_total_count'], bins=30, color='orange', edgecolor='black')
plt.xlabel('comm_ind_total_count')
plt.ylabel('Count')
plt.title('Histogram of comm_ind_total_count')
plt.grid(True)
plt.show()
```


```{python}
plt.figure(figsize=(8, 6))
plt.hist(pg_summary['pct_residential'], bins=100, color='green', edgecolor='black')
plt.xlabel('pct_residential')
plt.ylabel('Count')
plt.title('Histogram of pct_residential')
plt.grid(True)
plt.show()
```
